(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MzpNotification"] = factory();
	else
		root["MzpNotification"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 687:
/***/ (function(module) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

var MzpNotification = {};
var options = {};

/*
origin: element that triggered the notification.
options: object of params:
    title: title to display inside the notification. [required]
    cta: [Object] options for rendering an Anchor node after the title.
        text: text content for an Anchor element
        url: URL for the Anchor element
        attrs: map of additional options for the Anchor element, eg 'target', 'rel' etc
    className: CSS class name to apply to the notification.
    closeText: 'string to use for close button a11y.
    hasDismiss: boolean - include or not include dismiss button.
    isSticky: boolean - determines if notification is absolutely positioned and sticky.
    onNotificationOpen: function to fire after notification has been opened.
    onNotificationClose: function to fire after notification has been closed.
*/

MzpNotification.init = function (origin, opts) {
  if (_typeof(opts) === 'object') {
    for (var i in opts) {
      if (Object.prototype.hasOwnProperty.call(opts, i)) {
        options[i] = opts[i];
      }
    }
  }

  // Create new notification
  var title = document.createTextNode(options.title);
  var className = options && options.className ? options.className : '';
  var closeText = options && options.closeText ? options.closeText : '';
  var isSticky = options && options.isSticky ? 'mzp-is-sticky' : '';
  var ctaOptions = options && options.cta ? options.cta : {};
  var notification = document.createElement('aside');
  notification.className = 'mzp-c-notification-bar ' + className + ' ' + isSticky;
  var notificationContent = document.createElement('p');
  notification.appendChild(notificationContent);

  // Notification Title
  if (options && options.title) {
    notificationContent.appendChild(title);
  }

  // Notification CTA link
  if (options && options.cta) {
    var ctaAnchor = document.createElement('a'),
      ctaAttrs = ctaOptions.attrs ? ctaOptions.attrs : {};

    // build main <a> element, with the appropriate CSS class
    ctaAnchor.appendChild(document.createTextNode(ctaOptions.text));
    ctaAnchor.href = ctaOptions.url;
    ctaAnchor.className = 'mzp-c-notification-bar-cta';

    // If there are any extra attrs, add them to the element
    var key;
    for (key in ctaAttrs) {
      ctaAnchor.setAttribute(key, ctaAttrs[key]);
    }
    notificationContent.appendChild(ctaAnchor);
  }

  // Notification Fragment
  var notificationFragment = document.createDocumentFragment();
  notificationFragment.appendChild(notification);

  // Dismiss Button
  var dismissButton = '<button class="mzp-c-notification-bar-button" type="button">' + closeText + '</button>';

  // Show button & add event listener
  if (options && options.hasDismiss) {
    notificationFragment.childNodes[0].insertAdjacentHTML('afterbegin', dismissButton);
    var button = notificationFragment.querySelector('.mzp-c-notification-bar-button');
    button.setAttribute('title', closeText);
    button.addEventListener('click', _closeNotification, false);
  }

  // Add notification to page
  document.body.insertBefore(notificationFragment, document.body.childNodes[0]);

  // Remember which element opened the notification for later focus
  origin.classList.add('mzp-c-notification-origin');

  // Execute (optional) open callback
  if (options && typeof options.onNotificationOpen === 'function') {
    options.onNotificationOpen();
  }
};
var _closeNotification = function _closeNotification(e) {
  // remove notification from the page
  e.currentTarget.parentNode.remove();

  // execute (optional) callback
  if (options && typeof options.onNotificationClose === 'function') {
    options.onNotificationClose(e.target);
  }

  // free up options
  options = {};

  // restore focus to element that opened the notification
  var origin = document.querySelector('.mzp-c-notification-origin');
  origin.focus();
  origin.classList.remove('mzp-c-notification-origin');
};
module.exports = MzpNotification;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(687);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});