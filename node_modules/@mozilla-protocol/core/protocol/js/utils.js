(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MzpUtils"] = factory();
	else
		root["MzpUtils"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 959:
/***/ (function(module) {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

var MzpUtils = {};

/**
 * Element.matches() polyfill (IE8 support)
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
 * - https://vanillajstoolkit.com/polyfills/matches-ie8/
 */
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
    var matches = (this.document || this.ownerDocument).querySelectorAll(s);
    var i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {} // eslint-disable-line no-empty
    return i > -1;
  };
}

/**
 * nextUntil
 * @param {Object} el - Element that you want to get the siblings of
 * @param {String} selector - Selector of the element you want to stop collecting siblings before
 * @param {String} filter - Selector to filter results if you only want siblings matching this pattern
 * @return {Array} - an array of HTML elements
 * - https://gomakethings.com/how-to-get-all-sibling-elements-until-a-match-is-found-with-vanilla-javascript/
 */
MzpUtils.nextUntil = function (el, selector, filter) {
  // Setup siblings array
  var siblings = [];

  // Get the next sibling element
  el = el.nextElementSibling;

  // As long as a sibling exists
  while (el) {
    // If we've reached our match, bail
    if (el.matches(selector)) {
      break;
    }

    // If filtering by a selector, check if the sibling matches
    if (filter && !el.matches(filter)) {
      el = el.nextElementSibling;
      continue;
    }

    // Otherwise, push it to the siblings array
    siblings.push(el);

    // Get the next sibling element
    el = el.nextElementSibling;
  }
  return siblings;
};
module.exports = MzpUtils;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(959);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});